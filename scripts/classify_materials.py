#!/usr/bin/env python3
"""
Classify building materials — aligned with the ACTUAL roof geometry renderer.
Uses the exact same classifyRoof logic as LafayetteScene.jsx.
"""
import json, re, os, hashlib, math
from collections import Counter

with open('src/data/buildings.json') as f:
    data = json.load(f)
buildings = data['buildings']

# Load overrides (same as renderer)
with open('src/data/buildingOverrides.json') as f:
    overrides_data = json.load(f)
overrides = overrides_data.get('overrides', {})

# Load facade descriptions
facade_desc = {}
if os.path.exists('src/data/facade_mapping.json'):
    with open('src/data/facade_mapping.json') as f:
        fm = json.load(f)
    for bid, entry in fm.items():
        facade_desc[bid] = entry.get('description', '').lower()


def is_convex(pts):
    """Check if polygon is convex (same as JS isConvex)."""
    n = len(pts)
    if n < 3:
        return False
    sign = None
    for i in range(n):
        x1, y1 = pts[i]
        x2, y2 = pts[(i+1) % n]
        x3, y3 = pts[(i+2) % n]
        cross = (x2-x1)*(y3-y2) - (y2-y1)*(x3-x2)
        if abs(cross) < 1e-10:
            continue
        s = cross > 0
        if sign is None:
            sign = s
        elif s != sign:
            return False
    return True


def classify_roof_shape(b):
    """Exact replica of classifyRoof() from LafayetteScene.jsx."""
    ov = overrides.get(b['id'], {}).get('roof_shape')
    if ov is not None:
        return ov

    year = b.get('year_built') or 0
    stories = b.get('stories') or 1
    if not year:
        return 'flat'
    if stories >= 4:
        return 'flat'
    if stories == 1 and b.get('size', [0,0,0])[0] * b.get('size', [0,0,0])[2] > 500:
        return 'flat'
    if year < 1900 and stories >= 2 and stories <= 3:
        return 'mansard'
    if year < 1920 and stories >= 1 and stories <= 3:
        return 'hip'
    return 'flat'


def get_local_pts(b):
    """Get footprint in local coords (same as JS getLocalPts)."""
    fp = b.get('footprint')
    if not fp or len(fp) < 3:
        return None
    pos = b.get('position', [0,0,0])
    return [(p[0] - pos[0], p[1] - pos[2]) for p in fp]


def roof_actually_renders(b):
    """Check if the roof geometry will actually be generated by the renderer."""
    roof_shape = classify_roof_shape(b)
    if roof_shape == 'flat':
        return 'flat'

    local_pts = get_local_pts(b)
    if not local_pts:
        return 'flat'

    if roof_shape == 'mansard':
        if is_convex(local_pts):
            return 'mansard'
        else:
            return 'flat'  # renderer falls through to no roof
    elif roof_shape == 'hip':
        if len(local_pts) <= 8:
            return 'hip'
        else:
            return 'flat'

    return 'flat'


def classify_wall(b):
    """Wall material from description or style."""
    desc = facade_desc.get(b['id'], '')
    style = (b.get('architecture', {}).get('style') or '').lower()
    year = b.get('year_built') or 0

    if desc:
        if 'stone-clad' in desc or 'stone front' in desc or 'limestone front' in desc:
            return 'stone'
        if 'frame' in desc or 'clapboard' in desc:
            return 'wood_siding'
        if 'stucco' in desc or 'vinyl' in desc or 'aluminum siding' in desc:
            return 'stucco'
        if 'brick' in desc:
            return 'brick_red' if year < 1900 else 'brick_weathered'

    if 'craftsman' in style:
        return 'wood_siding'
    if 'art deco' in style or 'modernistic' in style:
        return 'stucco'

    if year and year >= 1970:
        return 'stucco'
    if year and year >= 1920:
        return 'brick_weathered'
    return 'brick_red'


# Wall tint colors — light enough to multiply with texture
WALL_TINTS = {
    'brick_red': [
        '#C4706A', '#B8706E', '#C07060', '#A86858', '#B07565',
        '#C08070', '#A87060', '#B87868', '#C47868', '#B06858',
    ],
    'brick_weathered': [
        '#C89080', '#D09888', '#C89078', '#D0A090', '#C89888',
        '#D89888', '#C8A088', '#D09080', '#C89888', '#D0A098',
    ],
    'stone': [
        '#D0C8B8', '#C8C0B0', '#D8D0C0', '#C8C0A8', '#D0C8B0',
        '#C0B8A8', '#D0C0B0', '#C8C0B8', '#D8D0C8', '#C0B8B0',
    ],
    'wood_siding': [
        '#C8B8A0', '#D0C0A8', '#C0B098', '#B8A890', '#C8B898',
        '#A8A098', '#B0A898', '#C0B8A8', '#D0C8B0', '#B8B0A0',
    ],
    'stucco': [
        '#D8D0C8', '#E0D8D0', '#D0C8C0', '#C8C0B8', '#D8D0D0',
        '#D0D0C8', '#C8C8C0', '#E0D8D8', '#D0C8C8', '#D8D8D0',
    ],
}


# === Classify ===
wall_counts = Counter()
roof_counts = Counter()

for b in buildings:
    # Wall
    wall = classify_wall(b)
    b['wall_material'] = wall
    wall_counts[wall] += 1

    # Roof — aligned with what actually renders
    actual_roof = roof_actually_renders(b)
    if actual_roof == 'mansard':
        b['roof_material'] = 'slate'
    elif actual_roof == 'hip':
        b['roof_material'] = 'metal'
    else:
        b['roof_material'] = 'flat'
    roof_counts[b['roof_material']] += 1

    # Color tint
    tints = WALL_TINTS.get(wall, WALL_TINTS['brick_red'])
    h = int(hashlib.md5(b['id'].encode()).hexdigest()[:8], 16)
    b['color'] = tints[h % len(tints)]

with open('src/data/buildings.json', 'w') as f:
    json.dump(data, f)

print("Material Classification (aligned with renderer)")
print("=" * 50)
print(f"\nWall materials ({len(buildings)} buildings):")
for m, c in wall_counts.most_common():
    print(f"  {m:20s}: {c:4d}  ({100*c/len(buildings):.0f}%)")
print(f"\nRoof materials (matches actual geometry):")
for m, c in roof_counts.most_common():
    print(f"  {m:20s}: {c:4d}  ({100*c/len(buildings):.0f}%)")
